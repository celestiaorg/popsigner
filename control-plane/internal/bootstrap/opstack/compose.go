package opstack

import (
	"bytes"
	"fmt"
	"text/template"
)

// Docker image versions for OP Stack services
const (
	OpNodeVersion     = "v1.16.3"
	OpBatcherVersion  = "v1.16.3" // Use release tag, not commit hash
	OpProposerVersion = "v1.10.0"
	OpGethVersion     = "v1.101602.3"
	OpAltDAVersion    = "v0.10.0"
)

// dockerComposeTemplate is the template for generating OP Stack docker-compose.yml with Celestia DA.
// Environment variables are loaded from .env file in the same directory.
// Run: docker compose up -d
const dockerComposeTemplate = `# {{ .ChainName }} - OP Stack with Celestia DA
# Generated by POPKins - https://popkins.popsigner.com
#
# Usage:
#   1. Copy .env.example to .env and fill in POPSIGNER_API_KEY
#   2. Run: docker compose up -d
#
# Environment variables are loaded from .env file automatically.

services:
{{- if .UseAltDA }}
  # =============================================================
  # OP-ALT-DA - Celestia DA Server
  # Posts blobs to Celestia, serves commitments to op-node/op-batcher
  # Uses POPSigner for Celestia transaction signing (see config.toml)
  # =============================================================
  op-alt-da:
    image: ghcr.io/celestiaorg/op-alt-da:{{ .OpAltDAVersion }}
    restart: unless-stopped
    volumes:
      - ./config.toml:/config/config.toml:ro
    command:
      - --config=/config/config.toml
    ports:
      - "3100:3100"
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:3100/health"]
      interval: 5s
      timeout: 3s
      retries: 60
{{- end }}

  # =============================================================
  # OP GETH INIT - Initialize genesis (runs once, then exits)
  # =============================================================
  op-geth-init:
    image: us-docker.pkg.dev/oplabs-tools-artifacts/images/op-geth:{{ .OpGethVersion }}
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        if [ -f /data/geth/chaindata/CURRENT ] || [ -d /data/geth/chaindata ]; then
          echo "op-geth already initialized, skipping genesis init"
        else
          echo "Initializing op-geth with genesis..."
          geth init --datadir=/data /config/genesis.json
        fi
    volumes:
      - ./op-geth/data:/data
      - ./genesis.json:/config/genesis.json:ro

  # =============================================================
  # OP GETH - L2 execution layer
  # =============================================================
  op-geth:
    image: us-docker.pkg.dev/oplabs-tools-artifacts/images/op-geth:{{ .OpGethVersion }}
    restart: unless-stopped
    depends_on:
      op-geth-init:
        condition: service_completed_successfully
    command:
      - --datadir=/data
      - --http
      - --http.addr=0.0.0.0
      - --http.port=8545
      - --http.vhosts=*
      - --http.corsdomain=*
      - --http.api=web3,debug,eth,txpool,net,engine,miner
      - --ws
      - --ws.addr=0.0.0.0
      - --ws.port=8546
      - --ws.origins=*
      - --ws.api=debug,eth,txpool,net,engine,miner
      - --syncmode=full
      - --gcmode=archive
      - --nodiscover
      - --maxpeers=0
      - --authrpc.addr=0.0.0.0
      - --authrpc.port=8551
      - --authrpc.vhosts=*
      - --authrpc.jwtsecret=/config/jwt.txt
      - --rollup.disabletxpoolgossip=true
      - --ipcdisable
      - --metrics
      - --metrics.port=7299
    volumes:
      - ./op-geth/data:/data
      - ./jwt.txt:/config/jwt.txt:ro
    ports:
      - "8545:8545"   # JSON-RPC
      - "8546:8546"   # WebSocket
      - "8551:8551"   # Engine API
      - "7299:7299"   # Metrics
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8545"]
      interval: 15s
      timeout: 5s
      retries: 20

  # =============================================================
  # OP NODE - Derives L2 state from L1, rollup consensus
  # =============================================================
  op-node:
    image: us-docker.pkg.dev/oplabs-tools-artifacts/images/op-node:{{ .OpNodeVersion }}
    restart: unless-stopped
    depends_on:
      op-geth:
        condition: service_healthy
{{- if .UseAltDA }}
      op-alt-da:
        condition: service_healthy
{{- end }}
    command:
      - op-node
      - --l2=http://op-geth:8551
      - --l2.jwt-secret=/config/jwt.txt
      - --sequencer.enabled
      - --sequencer.l1-confs=5
      - --verifier.l1-confs=4
      - --rollup.config=/config/rollup.json
      - --rpc.addr=0.0.0.0
      - --rpc.port=9545
      - --rpc.enable-admin
      - --p2p.disable
      - --l1=${L1_RPC_URL}
      - --l1.rpckind=${L1_RPC_KIND:-basic}
      - --l1.trustrpc
      - --l1.beacon=${L1_BEACON_URL}
      # NOTE: P2P signer not needed since --p2p.disable is set
      # For P2P-enabled sequencers, add:
      #   --p2p.sequencer.endpoint=${POPSIGNER_RPC_URL}
      #   --p2p.sequencer.address=${SEQUENCER_ADDRESS}
      #   --p2p.sequencer.header=X-API-Key:${POPSIGNER_API_KEY}
{{- if .UseAltDA }}
      # Celestia Alt-DA
      - --altda.enabled=true
      - --altda.verify-on-read=true
      - --altda.da-server=http://op-alt-da:3100
{{- end }}
      - --metrics.enabled
      - --metrics.port=7300
    volumes:
      - ./rollup.json:/config/rollup.json:ro
      - ./jwt.txt:/config/jwt.txt:ro
    ports:
      - "9545:9545"   # op-node RPC
      - "7300:7300"   # Metrics
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:9545"]
      interval: 15s
      timeout: 5s
      retries: 20

  # =============================================================
  # OP BATCHER - Submits L2 batches to DA layer
  # =============================================================
  op-batcher:
    image: us-docker.pkg.dev/oplabs-tools-artifacts/images/op-batcher:{{ .OpBatcherVersion }}
    restart: unless-stopped
    depends_on:
      op-geth:
        condition: service_healthy
      op-node:
        condition: service_healthy
{{- if .UseAltDA }}
      op-alt-da:
        condition: service_healthy
{{- end }}
    command:
      - op-batcher
      - --l2-eth-rpc=http://op-geth:8545
      - --rollup-rpc=http://op-node:9545
      - --poll-interval=1s
      - --sub-safety-margin=6
      - --num-confirmations=1
      - --safe-abort-nonce-too-low-count=3
      - --resubmission-timeout=30s
      - --rpc.addr=0.0.0.0
      - --rpc.port=8548
      - --max-channel-duration=25
      - --l1-eth-rpc=${L1_RPC_URL}
      # POPSigner for batcher signing
      - --signer.endpoint=${POPSIGNER_RPC_URL}
      - --signer.address=${BATCHER_ADDRESS}
      - --signer.header=X-API-Key:${POPSIGNER_API_KEY}
      - --signer.tls.enabled=false
{{- if .UseAltDA }}
      # Celestia Alt-DA
      - --altda.da-service=true
      - --altda.enabled=true
      - --altda.da-server=http://op-alt-da:3100
{{- end }}
      - --metrics.enabled
      - --metrics.port=7301
    ports:
      - "8548:8548"   # Batcher RPC
      - "7301:7301"   # Metrics
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8548/healthz"]
      interval: 15s
      timeout: 5s
      retries: 20

  # =============================================================
  # OP PROPOSER - Submits L2 state roots to L1
  # =============================================================
  op-proposer:
    image: us-docker.pkg.dev/oplabs-tools-artifacts/images/op-proposer:{{ .OpProposerVersion }}
    restart: unless-stopped
    depends_on:
      op-node:
        condition: service_healthy
    command:
      - op-proposer
      - --poll-interval=12s
      - --rpc.port=8560
      - --rollup-rpc=http://op-node:9545
      - --game-factory-address=${DISPUTE_GAME_FACTORY_ADDRESS}
      - --proposal-interval=6h
      - --l1-eth-rpc=${L1_RPC_URL}
      # POPSigner for proposer signing
      - --signer.endpoint=${POPSIGNER_RPC_URL}
      - --signer.address=${PROPOSER_ADDRESS}
      - --signer.header=X-API-Key:${POPSIGNER_API_KEY}
      - --signer.tls.enabled=false
      - --metrics.enabled
      - --metrics.port=7302
    ports:
      - "8560:8560"   # Proposer RPC
      - "7302:7302"   # Metrics
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8560/healthz"]
      interval: 15s
      timeout: 5s
      retries: 20

networks:
  default:
    name: {{ .ChainName }}-opstack
    driver: bridge
`

// opAltDAConfigTemplate is the config.toml template for op-alt-da v0.10.0
// 
// Uses POPSigner for Celestia transaction signing.
// No local keyring needed - POPSigner manages Celestia keys.
const opAltDAConfigTemplate = `# ==============================================================================
# Stateless DA Server Configuration
# ==============================================================================
#
# Generated by POPKins - https://popkins.popsigner.com
#
# This server submits blobs directly to Celestia and retrieves them on demand.
# No local database, no batching, no background workers - fully stateless.
#
# ==============================================================================

# Server listening address (use 0.0.0.0 for Docker)
addr = "0.0.0.0"

# Server listening port
port = 3100

# Log level: debug, info, warn, error
log_level = "info"

# Log format: text, terminal, logfmt, json, json-pretty
log_format = "text"

# HTTP server timeouts (protection against Slowloris/slow POST attacks)
read_timeout = "30s"
write_timeout = "120s"
idle_timeout = "60s"

# ==============================================================================
# CELESTIA CONFIGURATION
# ==============================================================================

[celestia]
# Celestia namespace (29 bytes hex, version 0 requires 18 leading zeros)
namespace = "{{ .CelestiaNamespace }}"

# Use compact blob IDs (height + commitment only, recommended)
blobid_compact = true

# ------------------------------------------------------------------------------
# Bridge Node (for reading blobs)
# ------------------------------------------------------------------------------
bridge_addr = "{{ .CelestiaBridgeAddr }}"
bridge_auth_token = "{{ .CelestiaBridgeAuthToken }}"
bridge_tls_enabled = false

# ------------------------------------------------------------------------------
# Core gRPC (for submitting blobs)
# ------------------------------------------------------------------------------
core_grpc_addr = "{{ .CelestiaGRPCAddr }}"
core_grpc_auth_token = "{{ .CelestiaGRPCAuthToken }}"
core_grpc_tls_enabled = true

# P2P network: mocha-4, arabica-11, celestia
p2p_network = "{{ .CelestiaNetwork }}"

# Parallel submission (0 = immediate, 1 = queued, >1 = parallel workers)
tx_worker_accounts = 0

# ==============================================================================
# SIGNER CONFIGURATION
# ==============================================================================
# POPSigner manages your Celestia signing keys - no local keyring setup needed!

[celestia.signer]
mode = "popsigner"

# ------------------------------------------------------------------------------
# POPSigner Configuration
# ------------------------------------------------------------------------------
# Keys remain remote. You remain sovereign.

[celestia.signer.popsigner]
api_key = "${POPSIGNER_API_KEY}"
key_id = "{{ .CelestiaKeyID }}"
base_url = "{{ .POPSignerAPIURL }}"

# ==============================================================================
# SUBMISSION CONFIGURATION
# ==============================================================================

[submission]
timeout = "60s"
tx_priority = 2
max_blob_size = "2MB"

# ==============================================================================
# READ CONFIGURATION
# ==============================================================================

[read]
timeout = "30s"

# ==============================================================================
# METRICS CONFIGURATION
# ==============================================================================

[metrics]
enabled = true
port = 6060

# ==============================================================================
# FALLBACK STORAGE CONFIGURATION (Optional)
# ==============================================================================

[fallback]
enabled = false
provider = "s3"
mode = "both"

[fallback.s3]
bucket = ""
prefix = ""
endpoint = ""
region = "us-east-1"
credential_type = "environment"
access_key_id = ""
access_key_secret = ""
timeout = "30s"
`

// ComposeTemplateVars holds variables for Docker Compose template.
type ComposeTemplateVars struct {
	// Chain identification
	ChainName string
	ChainID   uint64

	// L1 configuration
	L1RPC     string
	L1ChainID uint64

	// POPSigner configuration
	POPSignerEndpoint string
	POPSignerAPIKey   string

	// Role addresses
	SequencerAddress string
	BatcherAddress   string
	ProposerAddress  string

	// Contract addresses
	L2OutputOracle string

	// DA configuration - always Celestia
	UseAltDA bool // Always true - POPKins only supports Celestia

	// Celestia configuration
	CelestiaNamespace string
	CelestiaCoreGRPC  string
	CelestiaKeyName   string
	CelestiaNetwork   string

	// Image versions
	OpNodeVersion    string
	OpBatcherVersion string
	OpProposerVersion string
	OpGethVersion    string
	OpAltDAVersion   string
}

// GenerateDockerCompose generates a docker-compose.yml from the deployment config.
func GenerateDockerCompose(cfg *DeploymentConfig, artifacts *OPStackArtifacts) (string, error) {
	tmpl, err := template.New("docker-compose").Parse(dockerComposeTemplate)
	if err != nil {
		return "", fmt.Errorf("parse template: %w", err)
	}

	vars := ComposeTemplateVars{
		ChainName:         sanitizeChainName(cfg.ChainName),
		ChainID:           cfg.ChainID,
		L1RPC:             cfg.L1RPC,
		L1ChainID:         cfg.L1ChainID,
		POPSignerEndpoint: cfg.POPSignerEndpoint,
		POPSignerAPIKey:   "${POPSIGNER_API_KEY}", // Placeholder for .env
		SequencerAddress:  cfg.SequencerAddress,
		BatcherAddress:    cfg.BatcherAddress,
		ProposerAddress:   cfg.ProposerAddress,
		// Always use Celestia DA - POPKins only supports Celestia
		UseAltDA:          true,

		// Celestia configuration
		CelestiaNamespace: cfg.CelestiaNamespace, // Generated or user-provided
		CelestiaCoreGRPC:  "${CELESTIA_CORE_GRPC}",
		CelestiaKeyName:   "${CELESTIA_KEY_NAME}",
		CelestiaNetwork:   "${CELESTIA_NETWORK}",

		// Image versions
		OpNodeVersion:    OpNodeVersion,
		OpBatcherVersion: OpBatcherVersion,
		OpProposerVersion: OpProposerVersion,
		OpGethVersion:    OpGethVersion,
		OpAltDAVersion:   OpAltDAVersion,
	}

	// Get L2OutputOracle address from artifacts if available
	if artifacts != nil {
		vars.L2OutputOracle = artifacts.Addresses.L2OutputOracle
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, vars); err != nil {
		return "", fmt.Errorf("execute template: %w", err)
	}

	return buf.String(), nil
}

// AltDAConfigVars holds variables for the op-alt-da config.toml template.
type AltDAConfigVars struct {
	// Celestia network configuration
	CelestiaNamespace       string // hex-encoded namespace
	CelestiaNetwork         string // mocha-4, arabica-11, or celestia
	CelestiaBridgeAddr      string // Bridge/light node RPC for reading blobs
	CelestiaBridgeAuthToken string // Auth token for bridge node (if required)
	CelestiaGRPCAddr        string // Core gRPC for blob submission
	CelestiaGRPCAuthToken   string // Auth token for gRPC (if required)

	// POPSigner configuration
	POPSignerAPIURL string // API base URL (e.g., https://api.popsigner.com/)
	CelestiaKeyID   string // UUID of the Celestia key in POPSigner
}

// GenerateAltDAConfig generates the config.toml for op-alt-da (Celestia).
// Uses POPSigner for Celestia signing.
func GenerateAltDAConfig(cfg *DeploymentConfig) (string, error) {
	tmpl, err := template.New("altda-config").Parse(opAltDAConfigTemplate)
	if err != nil {
		return "", fmt.Errorf("parse template: %w", err)
	}

	// Determine Celestia network and default endpoints based on L1 chain
	celestiaNetwork := "mocha-4"
	// Default public endpoints - users should replace with their own provider
	celestiaBridgeAddr := "${CELESTIA_BRIDGE_ADDR}"
	celestiaGRPCAddr := "${CELESTIA_GRPC_ADDR}"
	if cfg.L1ChainID == 1 {
		// Mainnet deployment
		celestiaNetwork = "celestia"
	}

	// Use generated namespace or create one from chain ID
	celestiaNamespace := cfg.CelestiaNamespace
	if celestiaNamespace == "" {
		celestiaNamespace = fmt.Sprintf("0000000000000000000000000000000000000000%08x", cfg.ChainID)
	}

	// POPSigner API URL (not RPC - the API endpoint)
	popsignerAPIURL := "https://api.popsigner.com/"

	// Celestia key ID - use the configured one or placeholder
	celestiaKeyID := cfg.CelestiaKeyID
	if celestiaKeyID == "" {
		celestiaKeyID = "${CELESTIA_KEY_ID}"
	}

	vars := AltDAConfigVars{
		CelestiaNamespace:       celestiaNamespace,
		CelestiaNetwork:         celestiaNetwork,
		CelestiaBridgeAddr:      celestiaBridgeAddr,
		CelestiaBridgeAuthToken: "${CELESTIA_BRIDGE_AUTH_TOKEN}",
		CelestiaGRPCAddr:        celestiaGRPCAddr,
		CelestiaGRPCAuthToken:   "${CELESTIA_GRPC_AUTH_TOKEN}",
		POPSignerAPIURL:         popsignerAPIURL,
		CelestiaKeyID:           celestiaKeyID,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, vars); err != nil {
		return "", fmt.Errorf("execute template: %w", err)
	}

	return buf.String(), nil
}

// sanitizeChainName converts a chain name to a valid Docker network name.
func sanitizeChainName(name string) string {
	if name == "" {
		return "opstack"
	}

	// Replace spaces and special characters with hyphens
	result := make([]byte, 0, len(name))
	for i := 0; i < len(name); i++ {
		c := name[i]
		if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '-' || c == '_' {
			result = append(result, c)
		} else if c == ' ' {
			result = append(result, '-')
		}
	}

	if len(result) == 0 {
		return "opstack"
	}

	return string(result)
}

// SanitizeChainNameForFilename converts a chain name to a valid filename.
// Exported for use by the handler package.
func SanitizeChainNameForFilename(name string) string {
	return sanitizeChainName(name)
}

// GenerateMinimalCompose generates a minimal docker-compose for testing.
func GenerateMinimalCompose(cfg *DeploymentConfig) (string, error) {
	return GenerateDockerCompose(cfg, nil)
}
